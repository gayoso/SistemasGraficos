<!doctype html>
<meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
<meta content="ISO-8859-1" http-equiv="encoding">
<html>
    <head>
        <title>66.71 Sistemas Graficos: Gayoso - Keklikian</title>
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
			textarea{ background-color: black; foreground-color: white;}
        </style>

        <script type="text/javascript" src="gl-matrix.js"></script>
        <script type="text/javascript" src="color.js"></script>
        <script type="text/javascript" src="timer.js"></script>
		<script type="text/javascript" src="geometry.js"></script>
		<script type="text/javascript" src="cilindro.js"></script>
		<script type="text/javascript" src="trapecio.js"></script>
		<script type="text/javascript" src="triangulo.js"></script>
		<script type="text/javascript" src="circulo.js"></script>
		<script type="text/javascript" src="cuadrado.js"></script>
		<script type="text/javascript" src="cubo.js"></script>
		<script type="text/javascript" src="cono.js"></script>
		<script type="text/javascript" src="prismapentagonal.js"></script>
		<script type="text/javascript" src="prismahexagonal.js"></script>
		<script type="text/javascript" src="prismatriangular.js"></script>
		<script type="text/javascript" src="esfera.js"></script>
		<script type="text/javascript" src="dome.js"></script>
		<script type="text/javascript" src="curva.js"></script>
		<script type="text/javascript" src="conjunto.js"></script>
		<script type="text/javascript" src="mesh.js"></script>
		<script type="text/javascript" src="texturedmesh.js"></script>
		<script type="text/javascript" src="cabina.js"></script>
		<script type="text/javascript" src="vueltaalmundo.js"></script>
		<script type="text/javascript" src="montaniarusa.js"></script>
		<script type="text/javascript" src="sillasgiratorias.js"></script>
		<script type="text/javascript" src="track.js"></script>
		<script type="text/javascript" src="curvedgeometry.js"></script>
		<script type="text/javascript" src="scene.js"></script>
		<script type="text/javascript" src="light_point.js"></script>
		<script type="text/javascript" src="light_directional.js"></script>
        <!--
        Vertex shader con iluminacion

        El vertex shader define la posición y forma de cada vertice de cada polígono.
        --> 
        <script id="shader-vs-iluminacion" type="x-shader/x-vertex">
            // Los atributos son características propias de cada vertice.
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexColor;
			attribute vec3 aVertexNormal;
			attribute vec2 aTextureCoord;

            // Los uniforms son características propias de una etapa de dibujado completa.
            // Son comunes a todos los vertices involucrados en el dibujado.
			uniform mat4 uMMatrix;
			uniform mat4 uVMatrix;
            uniform mat4 uPMatrix;
			uniform mat4 uNMatrix;

            // Los varying son propiedades que toman valor para cada fragmento a partir
            // de interpolar linealmente entre los valores que se les asigna en cada 
            // vértice del polígono al cual pertenecen.
            varying vec3 vColor;
			varying vec3 vNormal;
			varying vec3 vertPos;
			varying vec2 vTextureCoord;
			
            void main(void) {
                // gl_Position es una variable "built-in" de GLSL que es usada para 
                // almacenar la posición resultante del fragmento.
                gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
				vertPos = vec3(uMMatrix * vec4(aVertexPosition, 1.0));
                vColor = aVertexColor;
				vNormal = vec3(uNMatrix * vec4(aVertexNormal, 0.0));
				vTextureCoord = aTextureCoord;
            }
        </script>

        <!--
        Fragment shader con iluminacion

        Cada pixel en un polígono se llama fragmento. El fragment shader se encarga de
        establecer el color de cada pixel. En este caso, asignamos el color blanco a 
        cada pixel.
        -->
        <script id="shader-fs-iluminacion" type="x-shader/x-fragment">
			precision highp float;
			// luces
			struct PointLight {
				vec3 position;
				vec3 ambient;
				vec3 intensity;
			};
			struct DirLight {
				vec3 direction;
				vec3 ambient;
				vec3 intensity;
			};
			uniform PointLight pointLights[25];
			uniform DirLight dirLights[25];
			uniform float numLights;
			
			// material
			uniform vec3 uViewPos;
			uniform vec3 uColorSpecular;
			uniform float uKa;
			uniform float uKd;
			uniform float uKs;
			uniform float uShininess;
			uniform bool uHasTexture;
			uniform bool uUseLights;
			
			varying vec3 vColor;
			varying vec3 vNormal;
			varying vec3 vertPos;
			varying vec2 vTextureCoord;
			
			uniform sampler2D uSampler;
			
			void main() {
				/*if(uHasTexture == true){
					gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
					return;
				}*/
				
				vec3 normal = normalize(vNormal);			
				vec3 viewDir = normalize(vertPos - uViewPos);
				vec3 color;
				if(uHasTexture){
					color = vec3(texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)));
				} else {
					color = vColor;
				}
				if(!uUseLights){
					gl_FragColor = vec4(color, 1.0);
					return;
				}
				vec3 color_final = vec3(0.0, 0.0, 0.0);
				
				// point lights
				for(int i = 0; i < 25; ++i){
				
					// cosas que dependen de cada luz
					vec3 Ia = pointLights[i].ambient; // luz ambiente (cada luz contribuye a esto)
					vec3 lightPos = pointLights[i].position;
					vec3 Ip = pointLights[i].intensity; // intensidad de la luz ficticia
					
					vec3 lightDir = normalize(lightPos - vertPos);
					vec3 reflectDir = reflect(-lightDir, normal);
					// esto es para el factor de atenuacion segun la distancia al observador
					// constantes (de 0 a 1)
					float c1 = 0.0;
					float c2 = 0.02;
					float c3 = 0.0;
					float dist_to_light = length(lightPos - vertPos);
					float fatt = min(1.0 / (c1 + c2*dist_to_light + c3*pow(dist_to_light, 2.0)), 1.0);			

					float lambertian = max(dot(lightDir,normal), 0.0);
					float specular = 0.0;

					if(lambertian > 0.0) {
					   float specAngle = max(dot(reflectDir, viewDir), 0.0);
					   specular = pow(specAngle, uShininess);
					}
					
					color_final += Ia * color * uKa + 
										(Ip / numLights) * fatt * (color * uKd * lambertian + 
													uColorSpecular * uKs * specular);
				}
				
				// dir lights
				for(int i = 0; i < 25; ++i){
				
					// cosas que dependen de cada luz
					vec3 Ia = dirLights[i].ambient; // luz ambiente (cada luz contribuye a esto)
					vec3 Ip = dirLights[i].intensity; // intensidad de la luz ficticia
					vec3 lightDir = normalize(dirLights[i].direction);
					
					vec3 reflectDir = reflect(-lightDir, normal);
					// esto es para el factor de atenuacion segun la distancia al observador
					// constantes (de 0 a 1)
					float c1 = 0.0;
					float c2 = 0.02;
					float c3 = 0.0;
					float dist_to_light = 9.0;
					float fatt = min(1.0 / (c1 + c2*dist_to_light + c3*pow(dist_to_light, 2.0)), 1.0);			

					float lambertian = max(dot(lightDir,normal), 0.0);
					float specular = 0.0;

					if(lambertian > 0.0) {
					   float specAngle = max(dot(reflectDir, viewDir), 0.0);
					   specular = pow(specAngle, uShininess);
					}
					
					color_final += Ia * color * uKa + 
										(Ip / numLights) * fatt * (color * uKd * lambertian + 
													uColorSpecular * uKs * specular);
				}
				gl_FragColor = vec4(color_final, 1.0);
			}
        </script>
		
		<!--
        Vertex shader pelado

        El vertex shader define la posición y forma de cada vertice de cada polígono.
        --> 
        <script id="shader-vs" type="x-shader/x-vertex">
            // Los atributos son características propias de cada vertice.
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexColor;
			attribute vec3 aVertexNormal;

            // Los uniforms son características propias de una etapa de dibujado completa.
            // Son comunes a todos los vertices involucrados en el dibujado.
			uniform mat4 uMMatrix;
			uniform mat4 uVMatrix;
            uniform mat4 uPMatrix;
			uniform mat4 uNMatrix;
			
			varying vec3 vColor;
			
            void main(void) {
                // gl_Position es una variable "built-in" de GLSL que es usada para 
                // almacenar la posición resultante del fragmento.
                gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
                vColor = aVertexColor;
            }
        </script>

        <!--
        Fragment shader pelado

        Cada pixel en un polígono se llama fragmento. El fragment shader se encarga de
        establecer el color de cada pixel. En este caso, asignamos el color blanco a 
        cada pixel.
        -->
        <script id="shader-fs" type="x-shader/x-fragment">
			precision highp float;
			// luces
			struct PointLight {
				vec3 position;
				vec3 ambient;
				vec3 intensity;
			};
			struct DirLight {
				vec3 direction;
				vec3 ambient;
				vec3 intensity;
			};
			uniform PointLight pointLights[25];
			uniform DirLight dirLights[25];
			uniform float numLights;
			
			// material
			uniform vec3 uViewPos;
			uniform vec3 uColorSpecular;
			uniform float uKa;
			uniform float uKd;
			uniform float uKs;
			uniform float uShininess;
			
			varying vec3 vColor;
			varying vec3 vNormal;
			varying vec3 vertPos;
			
			void main() {
				gl_FragColor = vec4(vColor, 1.0);
			}
        </script>

        <script>
            var gl = null,
                canvas = null,
                glProgram = null,
                fragmentShader = null,
                vertexShader = null,
                t = 0.0;
				sillas_giratorias = null,
				vuelta_al_mundo = null,
				montania_rusa = null;

            var mvMatrix = mat4.create();
            var pMatrix = mat4.create();
            var vMatrix = mat4.create();
            var mouseDown = false;
  			var lastMouseX = null;
  			var lastMouseY = null;
  			var puntoOjo = null;
            var puntoMirado = null;
            var vecArriba = null;
            var camara = 1;

			function handleMouseDown(event) {
			    mouseDown = true;
			    lastMouseX = event.clientX;
			    lastMouseY = event.clientY;
			}

			function handleMouseUp(event) {
			    mouseDown = false;
			}

			function handleMouseMove(event) {
				if(camara == 1){

				    if (!mouseDown) {
				      return;
				    }
				    var newX = event.clientX;
				    var newY = event.clientY;

				    var deltaX = newX - lastMouseX;
				    var deltaY = newY - lastMouseY;
	                var deltaP = vec3.create();
	            
	                vec3.subtract(deltaP, puntoOjo, puntoMirado);

	                var matR = mat4.create();
	                
	                mat4.identity(matR);
	                mat4.rotate(matR, matR, -deltaX/100, vecArriba);
	                var ejeDeRotacion = vec3.create();
	                vec3.cross(ejeDeRotacion, vecArriba, deltaP);
	                mat4.rotate(matR, matR, -deltaY/100, ejeDeRotacion);
	                vec3.transformMat4(deltaP, deltaP, matR);
	                vec3.transformMat4(vecArriba, vecArriba, matR);
	                vec3.add(puntoOjo, deltaP, puntoMirado);


	                lastMouseX = newX;
				    lastMouseY = newY;
				}
				if(camara == 2){
					var newX = event.clientX;
				    var newY = event.clientY;

				    var deltaX = newX - lastMouseX;
				    var deltaY = newY - lastMouseY;
	                var deltaP = vec3.create();
	            
	                vec3.subtract(deltaP, puntoMirado, puntoOjo);

	                var matR = mat4.create();
	                
	                mat4.identity(matR);
	                mat4.rotate(matR, matR, -deltaX/600, vecArriba);
	                var ejeDeRotacion = vec3.create();
	                vec3.cross(ejeDeRotacion, vecArriba, deltaP);
	                mat4.rotate(matR, matR, deltaY/600, ejeDeRotacion);
	                vec3.transformMat4(deltaP, deltaP, matR);
	                vec3.transformMat4(vecArriba, vecArriba, matR);
	                vec3.add(puntoMirado, deltaP, puntoOjo);


	                lastMouseX = newX;
				    lastMouseY = newY;
				}

			}

			function handleMouseWheel(event){
				var delta;
				if (event.wheelData){
					delta = event.wheelData
				} else if (event.detail){
					delta = event.detail;
				}

				var deltaP = vec3.create();

				vec3.subtract(deltaP, puntoOjo, puntoMirado);

				vec3.scale(deltaP, deltaP, delta/10+1);
				vec3.add(puntoOjo, puntoMirado, deltaP);
			}

			function handleKeyDown(event){
				if (String.fromCharCode(event.keyCode) == "C") {
					camara = (camara + 1) % 3;
				}
				if(camara == 2){
					var deltaP = vec3.create();
					vec3.subtract(deltaP, puntoOjo, puntoMirado);
					vec3.normalize(deltaP, deltaP);
					if (String.fromCharCode(event.keyCode) == "W") {
						vec3.subtract(puntoOjo, puntoOjo, deltaP);
						vec3.subtract(puntoMirado, puntoMirado, deltaP);
					}
					if (String.fromCharCode(event.keyCode) == "A") {
						vec3.cross(deltaP, deltaP, vecArriba);
						vec3.add(puntoOjo, puntoOjo, deltaP);
						vec3.add(puntoMirado, puntoMirado, deltaP);
					}
					if (String.fromCharCode(event.keyCode) == "S") {
						vec3.add(puntoOjo, puntoOjo, deltaP);
						vec3.add(puntoMirado, puntoMirado, deltaP);
					}
					if (String.fromCharCode(event.keyCode) == "D") {
						vec3.cross(deltaP, deltaP, vecArriba);
						vec3.subtract(puntoOjo, puntoOjo, deltaP);
						vec3.subtract(puntoMirado, puntoMirado, deltaP);
					}
				}
			}


             // SHADERS FUNCTION
            function getShader(gl, id) {
                var shaderScript, src, currentChild, shader;

                // Obtenemos el elemento <script> que contiene el código fuente del shader.
                shaderScript = document.getElementById(id);
                if (!shaderScript) {
                    return null;
                }

                // Extraemos el contenido de texto del <script>.
                src = "";
                currentChild = shaderScript.firstChild;
                while(currentChild) {
                    if (currentChild.nodeType == currentChild.TEXT_NODE) {
                        src += currentChild.textContent;
                    }
                    currentChild = currentChild.nextSibling;
                }

                // Creamos un shader WebGL según el atributo type del <script>.
                if (shaderScript.type == "x-shader/x-fragment") {
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                } else if (shaderScript.type == "x-shader/x-vertex") {
                    shader = gl.createShader(gl.VERTEX_SHADER);
                } else {
                    return null;
                }

                // Le decimos a WebGL que vamos a usar el texto como fuente para el shader.
                gl.shaderSource(shader, src);

                // Compilamos el shader.
                gl.compileShader(shader);  
                  
                // Chequeamos y reportamos si hubo algún error.
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
                  alert("An error occurred compiling the shaders: " + 
                        gl.getShaderInfoLog(shader));  
                  return null;  
                }
                  
                return shader;
            }

            function initWebGL()
            {
                canvas = document.getElementById("my-canvas");  
                try{
                    gl = canvas.getContext("webgl", { preserveDrawingBuffer: true }) || canvas.getContext("experimental-webgl", { preserveDrawingBuffer: true });     
                    canvas.onmousedown = handleMouseDown;
                    document.onmouseup = handleMouseUp;
                    document.onmousemove = handleMouseMove; 
                    document.onkeydown = handleKeyDown;
                    document.onkeyup = handleKeyUp;  
                    window.addEventListener('DOMMouseScroll', handleMouseWheel);


                }catch(e){
                }
                                
                if(gl)
                {
                    setupWebGL();
                    initShaders();
                    setupBuffers();
					requestAnimationFrame(drawScene);
                }else{    
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }
            }
            
            function setupWebGL()
            {
                //set the clear color
                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.enable(gl.DEPTH_TEST);                              
                gl.depthFunc(gl.LEQUAL); 
                gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
                
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            function initShaders()
            {
                // Obtenemos los shaders ya compilados
                var fragmentShader = getShader(gl, "shader-fs-iluminacion");
                var vertexShader = getShader(gl, "shader-vs-iluminacion");

                // Creamos un programa de shaders de WebGL.
                glProgram = gl.createProgram();

                // Asociamos cada shader compilado al programa.
                gl.attachShader(glProgram, vertexShader);
                gl.attachShader(glProgram, fragmentShader);

                // Linkeamos los shaders para generar el programa ejecutable.
                gl.linkProgram(glProgram);

                // Chequeamos y reportamos si hubo algún error.
                if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                  alert("Unable to initialize the shader program: " + 
                        gl.getProgramInfoLog(glProgram));
                  return null;
                }
  
                // Le decimos a WebGL que de aquí en adelante use el programa generado.
                gl.useProgram(glProgram);
            }
            
            function makeShader(src, type)
            {
                //compile the vertex shader
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
                }
                return shader;
            }
			
            function setupBuffers()
            {
				/*** DESCOMENTAR ESTO PARA QUE SE CREEN Y ORIENTEN (mas o menos lindo) ESTOS MODELOS ***/
				/*** ESTO YA ESTA TERIMINADO, LO DEJO ACA POR AHORA ***/
				vuelta_al_mundo = new VueltaAlMundo();
				var m1 = mat4.create();
				mat4.translate(m1, m1, vec3.fromValues(-20, 17.1, -10));
				mat4.rotate(m1, m1, -Math.PI/3, vec3.fromValues(0, 1, 0));
				mat4.scale(m1, m1, vec3.fromValues(4, 4, 4));
				vuelta_al_mundo.setTransform(m1);
				
				sillas_giratorias = new SillasGiratorias();
				var m2 = mat4.create();
				mat4.translate(m2, m2, vec3.fromValues(5, -11.99, 10));
				mat4.rotate(m2, m2, -Math.PI/3, vec3.fromValues(0, 1, 0));
				mat4.scale(m2, m2, vec3.fromValues(2, 2, 2));
				sillas_giratorias.setTransform(m2);

				//montania_rusa = new MontaniaRusa();
				
				/*** ESTOS PUNTOS SE USAN EN LA CREACION DE LAS CURVAS ***/
				// es un posible recorrido de la montaña rusa, puede ser otro da lo mismo
				
				/*var puntos = [];
				puntos.push(vec3.fromValues(5, 2, 0));
				puntos.push(vec3.fromValues(5, 2, 4));
				puntos.push(vec3.fromValues(5, 3, 5.5));
				puntos.push(vec3.fromValues(5, 4, 7));
				// giros horizontales
				puntos.push(vec3.fromValues(5, 6, 8));
				puntos.push(vec3.fromValues(7, 6.5, 10));
				puntos.push(vec3.fromValues(8, 6.25, 9.5));
				puntos.push(vec3.fromValues(8.5, 6, 9));
				puntos.push(vec3.fromValues(8, 6, 8.5));
				puntos.push(vec3.fromValues(7.5, 6, 9));
				puntos.push(vec3.fromValues(8, 5.75, 9.5));
				puntos.push(vec3.fromValues(8.5, 5.5, 9));
				puntos.push(vec3.fromValues(8, 5.25, 8.5));
				puntos.push(vec3.fromValues(7.5, 5.25, 9));
				puntos.push(vec3.fromValues(8, 5.25, 9.5));
				puntos.push(vec3.fromValues(8.5, 5, 9));
				// end
				puntos.push(vec3.fromValues(8.5, 4.5, 8));
				puntos.push(vec3.fromValues(8.75, 3, 5));
				puntos.push(vec3.fromValues(9, 5, 3));
				puntos.push(vec3.fromValues(8.8, 7, 4));
				puntos.push(vec3.fromValues(8.6, 5, 5));
				puntos.push(vec3.fromValues(8.5, 3, 4));
				puntos.push(vec3.fromValues(8.3, 3, 2));
				puntos.push(vec3.fromValues(8, 2.5, 0.5));
				puntos.push(vec3.fromValues(5, 2, 0));*/
				
				
				/*** DESCOMENTAR ESTO PARA CREAR UNA CURVA ***/
				/*curva1 = new Mesh( new Curva(puntos) );
				var m1 = mat4.create();
				var centro = curva1.getCenter();
				vec3.scale(centro, centro, -1);
				mat4.translate(m1, m1, centro);
				curva1.applyMatrix(m1);*/
				
				/*** DESCOMENTAR ESTO PARA CREAR EL MODELO DE TRACK ***/
				// Track tiene un modelo de riel para la montaña rusa, pero no logre hacer que funcione bien
				// la idea era definir en curva que arme la curva aproximando con rectas de largo predefinido
				// asi le pasaba el largo del modelo este, y despues era cuestion de ponerlo en cada lugar y orientarlo
				/*track = new Track();
				
				var p0 = vec3.fromValues(0, 0, 0);
				var p1 = vec3.fromValues(4, 0, 0);
				// esta funcion deberia trasladar el riel al punto p0, y orientarlo segun el vector p0p1
				// crei que estaba bien hecho, pero cuando lo pruebo en curva2 queda horrible y no alineado
				track.fitToSegment(p0, p1);*/
				
				/*** DESCOMENTAR PARA CREAR CURVA CON TRACKS (anda para el orto y puede que se laguee banda) ***/
				//curva2 = new CurvedGeometry(puntos, new Track());
                puntoOjo = vec3.fromValues(0,0,-80);
                puntoMirado = vec3.fromValues(0,0,0);
                //vecArriba = vec3.fromValues(-0.38,0.92,0);
                vecArriba = vec3.fromValues(0,1,0);
				
				/*** CREO LA ESCENA ***/
				escena = new Scene();
				escena.addConjunto(vuelta_al_mundo);
				escena.addConjunto(sillas_giratorias);

				// esta es una luz blanca de arriba (de infinito)
				escena.addLight(new DirectionalLight(vec3.fromValues(0.0, 1.0, -0.5), 
											vec3.fromValues(0.8, 0.8, 0.8), 
											vec3.fromValues(0.9, 0.9, 0.9)));
				// esta es una luz blanca en un costado (sale de donde esta la esfera)
				/*escena.addLight(new PointLight(vec3.fromValues(0.0, 100.0, -30.0), 
											vec3.fromValues(1.0, 1.0, 1.0), 
											vec3.fromValues(0.0, 0.0, 0.0)));*/
				
				/*** ESTO DEFINE LA GEOMETRIA DEL PISO, SU TEXTURA Y COMO MAPEARLA ***/
				var mapper_piso = function(){
					var cant_tiles = 50;
					var buffer = [];
					
					buffer.push(0);
					buffer.push(0);
					
					buffer.push(cant_tiles);
					buffer.push(0);
					
					buffer.push(0);
					buffer.push(cant_tiles);
					
					buffer.push(cant_tiles);
					buffer.push(cant_tiles);
					
					return buffer;
				}
				
				piso = new TexturedMesh( "156.jpg", mapper_piso, new Cuadrado() );
				m_piso = mat4.create();
				mat4.translate(m_piso, m_piso, vec3.fromValues(0, -15, 0));
				mat4.rotate(m_piso, m_piso, -Math.PI/2, vec3.fromValues(1, 0, 0));
				mat4.scale(m_piso, m_piso, vec3.fromValues(1000, 1000, 1000));
				piso.applyMatrix(m_piso);
				escena.addConjunto(piso);
				
				/*** ESTO DEFINE LA GEOMETRIA DEL CIELO, SU TEXTURA Y COMO MAPEARLA ***/
				var mapper_cielo = function (){
					var buffer = [];
					for (var i = 0.0; i < 50; i++) {
						for (var j = 0.0; j < 50; j++) {
							
							buffer.push(1-j/50);
							buffer.push(1-i/50);
						}
					}
					return buffer;
				}
				
				cielo = new TexturedMesh("sky.jpg", mapper_cielo, new Esfera(), false);
				m_cielo = mat4.create();
				mat4.translate(m_cielo, m_cielo, vec3.fromValues(0, -15, 0));
				mat4.scale(m_cielo, m_cielo, vec3.fromValues(500, 500, 500));
				mat4.rotate(m_cielo, m_cielo, -Math.PI/2, vec3.fromValues(1, 0, 0));
				cielo.applyMatrix(m_cielo);
				escena.addConjunto(cielo);
            }
            
            function drawScene()
            {
				requestAnimationFrame(drawScene);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				
				// esto estaba aca en el ejemplo de clase, pero creo que podria ir en otro lado
				
                // Preparamos una matriz de perspectiva.
				var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
                mat4.perspective(pMatrix, 45, 640.0/480.0, 0.1, 100000.0);
                gl.uniformMatrix4fv(u_proj_matrix, false, pMatrix);
				
                // Preparamos una matriz de vista.
				var u_view_matrix = gl.getUniformLocation(glProgram, "uVMatrix");
                mat4.identity(vMatrix);
				mat4.lookAt(vMatrix, puntoOjo, puntoMirado, vecArriba);
				gl.uniformMatrix4fv(u_view_matrix, false, vMatrix);
				
				// Preparams la posicion del observador
				var u_view_dir = gl.getUniformLocation(glProgram, "uViewPos");
				gl.uniform3fv(u_view_dir, puntoOjo);
				
                t = t + 0.1;
				
				// Transformaciones a los modelos
				/*** DESCOMENTAR ESTO PARA QUE LOS MODELOS GIREN ***/
				/*** ESTO YA ESTA TERIMINADO, LO DEJO ACA POR AHORA ***/
				vuelta_al_mundo.girar();				
				sillas_giratorias.girar();
				
				// Dibujar modelos
				/*** DESCOMENTAR ESTO PARA QUE LOS MODELOS SE DIBUJEN ***/
				/*** ESTO YA ESTA TERIMINADO, LO DEJO ACA POR AHORA ***/
				escena.render();
            }

        </script>
    </head>
    <body onload="initWebGL()">
		<center>
			<h1>Sistemas Gráficos - 66.71</h1>
			<h2>WebGL - Grilla de vértices</h2>
			<canvas id="my-canvas" width="900" height="500">
			Your browser does not support the HTML5 canvas element.
			</scanvas>
			
		</center>
    </body>
</html>
