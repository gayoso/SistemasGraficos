<!doctype html>
<head>
	<title>66.71 Sistemas Graficos: Gayoso - Keklikian</title>
	<style>
		body{ background-color: grey; }
		canvas{ background-color: white; }
		textarea{ background-color: black; foreground-color: white;}
	</style>

	<script type="text/javascript" src="gl-matrix.js"></script>
	<script type="text/javascript" src="reflectionmanager.js"></script>
	<script type="text/javascript" src="color.js"></script>
	<script type="text/javascript" src="timer.js"></script>
	<script type="text/javascript" src="geometry.js"></script>
	<script type="text/javascript" src="cilindro.js"></script>
	<script type="text/javascript" src="trapecio.js"></script>
	<script type="text/javascript" src="triangulo.js"></script>
	<script type="text/javascript" src="circulo.js"></script>
	<script type="text/javascript" src="cuadrado.js"></script>
	<script type="text/javascript" src="cubo.js"></script>
	<script type="text/javascript" src="cono.js"></script>
	<script type="text/javascript" src="prismapentagonal.js"></script>
	<script type="text/javascript" src="prismahexagonal.js"></script>
	<script type="text/javascript" src="prismatriangular.js"></script>
	<script type="text/javascript" src="esfera.js"></script>
	<script type="text/javascript" src="dome.js"></script>
	<script type="text/javascript" src="curva.js"></script>
	<script type="text/javascript" src="conjunto.js"></script>
	<script type="text/javascript" src="mesh.js"></script>
	<script type="text/javascript" src="texturedmesh.js"></script>
	<script type="text/javascript" src="cabina.js"></script>
	<script type="text/javascript" src="vueltaalmundo.js"></script>
	<script type="text/javascript" src="montaniarusa.js"></script>
	<script type="text/javascript" src="sillasgiratorias.js"></script>
	<script type="text/javascript" src="track.js"></script>
	<script type="text/javascript" src="curvedgeometry.js"></script>
	<script type="text/javascript" src="scene.js"></script>
	<script type="text/javascript" src="light_point.js"></script>
	<script type="text/javascript" src="light_directional.js"></script>
	<script type="text/javascript" src="agua.js"></script>
	<!--
	Vertex shader con iluminacion

	El vertex shader define la posición y forma de cada vertice de cada polígono.
	--> 
	<script id="shader-vs-iluminacion" type="x-shader/x-vertex">
		// Los atributos son características propias de cada vertice.
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexColor;
		attribute vec3 aVertexNormal;
		attribute vec2 aTextureCoord;
		attribute vec3 aVertexTangent;
		attribute vec3 aVertexBinormal;

		// Los uniforms son características propias de una etapa de dibujado completa.
		// Son comunes a todos los vertices involucrados en el dibujado.
		uniform mat4 uMMatrix;
		uniform mat4 uVMatrix;
		uniform mat4 uPMatrix;
		uniform mat4 uNMatrix;

		// Los varying son propiedades que toman valor para cada fragmento a partir
		// de interpolar linealmente entre los valores que se les asigna en cada 
		// vértice del polígono al cual pertenecen.
		varying vec3 vColor;
		varying vec3 vNormal;
		varying vec3 vTangente;
		varying vec3 vBinormal;
		varying vec3 vertPos;
		varying vec2 vTextureCoord;
		
		void main(void) {
			// gl_Position es una variable "built-in" de GLSL que es usada para 
			// almacenar la posición resultante del fragmento.
			gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
			vertPos = vec3(uMMatrix * vec4(aVertexPosition, 1.0));
			vColor = aVertexColor;
			vNormal = normalize(vec3(uNMatrix * vec4(normalize(aVertexNormal), 0.0)));
			vBinormal = normalize(vec3(uNMatrix * vec4(normalize(aVertexBinormal), 0.0)));
			vTangente = normalize(vec3(uNMatrix * vec4(normalize(aVertexTangent), 0.0)));
			vTextureCoord = aTextureCoord;
		}
	</script>

	<!--
	Fragment shader con iluminacion

	Cada pixel en un polígono se llama fragmento. El fragment shader se encarga de
	establecer el color de cada pixel. En este caso, asignamos el color blanco a 
	cada pixel.
	-->
	<script id="shader-fs-iluminacion" type="x-shader/x-fragment">
		precision highp float;
		// luces
		struct PointLight {
			vec3 position;
			vec3 ambient;
			vec3 intensity;
		};
		struct DirLight {
			vec3 direction;
			vec3 ambient;
			vec3 intensity;
		};
		uniform PointLight pointLights[25];
		uniform DirLight dirLights[25];
		uniform float numLights;
		
		// material
		uniform vec3 uViewPos;
		uniform vec3 uColorSpecular;
		uniform float uKa;
		uniform float uKd;
		uniform float uKs;
		uniform float uShininess;
		uniform float uReflectiveness;
		uniform bool uHasTexture;
		uniform bool uUseLights;
		uniform float uTime;
		uniform bool uUseWaterEffect;
		uniform bool uBlendTexture;
		
		uniform bool uUseNormalMap;
		uniform bool uUseReflection;
		
		varying vec3 vColor;
		varying vec3 vNormal;
		varying vec3 vTangente;
		varying vec3 vBinormal;
		varying vec3 vertPos;
		varying vec2 vTextureCoord;
		
		uniform sampler2D uSampler;
		uniform sampler2D uNormalSampler;
		uniform samplerCube uCubeSampler;
		
		void main() {
			
			vec2 texCoord = vTextureCoord;
			vec2 secTexCoord = vTextureCoord;
			float mix_factor = 1.0;

			if(uUseWaterEffect){
				mix_factor = 0.5;
				secTexCoord = vec2(secTexCoord.t, -secTexCoord.s) * 2.0;
				texCoord.t += uTime/10000.0;
				secTexCoord.t += uTime/10000.0;
			}
			
			vec3 normal = normalize(vNormal);	
			if (uUseNormalMap){
				vec3 tangent = normalize(vTangente);
				vec3 binormal = normalize(vBinormal);
			
				mat3 tbn = mat3(tangent, binormal, normal);
				normal = texture2D(uNormalSampler, texCoord).xyz;
				normal = mix(normal, texture2D(uNormalSampler, secTexCoord).xyz, mix_factor);
				normal = normalize((normal - vec3(0.5, 0.5, 0.5)) * 2.0);
			
				//Transform the normal vector in the RGB channels to tangent space
				normal = normalize(tbn * normal);
			}
			
			vec3 viewDir = normalize(vertPos - uViewPos);
			vec3 color = vColor;
			if(uHasTexture){
				color = texture2D(uSampler, texCoord).rgb;
				color = mix(color, texture2D(uSampler, secTexCoord).rgb, mix_factor);
				if(uBlendTexture){
					color *= vColor;
				}
			}

			if(!uUseLights){
				gl_FragColor = vec4(color, 1.0);
				return;
			}
			
			if (uUseReflection) {

				//vec3 eyeDirection = normalize(-vPosition.xyz);
				//vec3 lookup = reflect(eyeDirection, normal);
				vec3 lookup = reflect(viewDir, normal);
				color = mix(color, vec3(textureCube(uCubeSampler, lookup)), uReflectiveness);
				//color *= vec3(textureCube(uCubeSampler, -lookup));
			}
			
			vec3 color_final = vec3(0.0, 0.0, 0.0);
			
			// point lights
			for(int i = 0; i < 25; ++i){
			
				// cosas que dependen de cada luz
				vec3 Ia = pointLights[i].ambient; // luz ambiente (cada luz contribuye a esto)
				vec3 lightPos = pointLights[i].position;
				vec3 Ip = pointLights[i].intensity; // intensidad de la luz ficticia
				
				vec3 lightDir = normalize(lightPos - vertPos);
				vec3 reflectDir = reflect(lightDir, normal);
				// esto es para el factor de atenuacion segun la distancia al observador
				// constantes (de 0 a 1)
				float c1 = 0.0;
				float c2 = 0.02;
				float c3 = 0.0;
				float dist_to_light = length(lightPos - vertPos);
				float fatt = min(1.0 / (c1 + c2*dist_to_light + c3*pow(dist_to_light, 2.0)), 1.0);			

				float lambertian = max(abs(dot(lightDir,normal)), 0.0);
				float specular = 0.0;

				if(lambertian > 0.0) {
				   float specAngle = max(dot(reflectDir, viewDir), 0.0);
				   specular = pow(specAngle, uShininess);
				}
				
				color_final += Ia * color * uKa + 
									(Ip/* / numLights*/) * fatt * (color * uKd * lambertian + 
												uColorSpecular * uKs * specular);
			}
			
			// dir lights
			for(int i = 0; i < 25; ++i){
			
				// cosas que dependen de cada luz
				vec3 Ia = dirLights[i].ambient; // luz ambiente (cada luz contribuye a esto)
				vec3 Ip = dirLights[i].intensity; // intensidad de la luz ficticia
				vec3 lightDir = normalize(dirLights[i].direction);
				
				vec3 reflectDir = reflect(lightDir, normal);
				// esto es para el factor de atenuacion segun la distancia al observador
				// constantes (de 0 a 1)
				float c1 = 0.0;
				float c2 = 0.02;
				float c3 = 0.0;
				float dist_to_light = 9.0;
				float fatt = min(1.0 / (c1 + c2*dist_to_light + c3*pow(dist_to_light, 2.0)), 1.0);			

				float lambertian = max(dot(lightDir,normal), 0.0);
				float specular = 0.0;

				if(lambertian > 0.0) {
				   float specAngle = max(dot(reflectDir, viewDir), 0.0);
				   specular = pow(specAngle, uShininess);
				}
				
				color_final += Ia * color * uKa + 
									(Ip/* / numLights*/) * fatt * (color * uKd * lambertian + 
												uColorSpecular * uKs * specular);
			}
			gl_FragColor = vec4(color_final, 1.0);
		}
	</script>
	

	<script>
		var gl = null,
			canvas = null,
			glProgram = null,
			fragmentShader = null,
			vertexShader = null,
			t = 0.0,
			sillas_giratorias = null,
			vuelta_al_mundo = null,
			piso = null,
			cielo_dia = null,
			cielo_noche = null,
			agua = null,
			montania_rusa = null,
			mode = "day",
			light_dia = null,
			light_noche1 = null,
			light_noche2 = null,
			light_noche3 = null,
			light_noche4 = null,
			light_noche5 = null,
			light_noche6 = null;

		var mvMatrix = mat4.create();
		var pMatrix = mat4.create();
		var vMatrix = mat4.create();
		var mouseDown = false;
		var lastMouseX = null;
		var lastMouseY = null;
		var puntoOjo = null;
		var puntoMirado = null;
		var vecArriba = null;
		var camara = 1;
		
		/**
		* Provides requestAnimationFrame in a cross browser way.
		* @author paulirish / http://paulirish.com/
		*/
		if ( !window.requestAnimationFrame ) {
			window.requestAnimationFrame = ( function() {
				return window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {
					window.setTimeout( callback, 1000 / 60 );
				};
			} )();
		}

		function handleMouseDown(event) {
			mouseDown = true;
			lastMouseX = event.clientX;
			lastMouseY = event.clientY;
		}

		function handleMouseUp(event) {
			mouseDown = false;
		}

		function handleMouseMove(event) {
			if(camara == 1){

				if (!mouseDown) {
				  return;
				}
				var newX = event.clientX;
				var newY = event.clientY;

				var deltaX = newX - lastMouseX;
				var deltaY = newY - lastMouseY;
				var deltaP = vec3.create();
			
				vec3.subtract(deltaP, puntoOjo, puntoMirado);

				var matR = mat4.create();
				
				mat4.identity(matR);
				mat4.rotate(matR, matR, -deltaX/100, vecArriba);
				var ejeDeRotacion = vec3.create();
				vec3.cross(ejeDeRotacion, vecArriba, deltaP);
				mat4.rotate(matR, matR, -deltaY/100, ejeDeRotacion);
				vec3.transformMat4(deltaP, deltaP, matR);
				vec3.transformMat4(vecArriba, vecArriba, matR);
				vec3.add(puntoOjo, deltaP, puntoMirado);


				lastMouseX = newX;
				lastMouseY = newY;
			}
			if(camara == 2){
				var newX = event.clientX;
				var newY = event.clientY;

				var deltaX = newX - lastMouseX;
				var deltaY = newY - lastMouseY;
				var deltaP = vec3.create();
			
				vec3.subtract(deltaP, puntoMirado, puntoOjo);

				var matR = mat4.create();
				
				mat4.identity(matR);
				mat4.rotate(matR, matR, -deltaX/600, vecArriba);
				var ejeDeRotacion = vec3.create();
				vec3.cross(ejeDeRotacion, vecArriba, deltaP);
				mat4.rotate(matR, matR, deltaY/600, ejeDeRotacion);
				vec3.transformMat4(deltaP, deltaP, matR);
				vec3.transformMat4(vecArriba, vecArriba, matR);
				vec3.add(puntoMirado, deltaP, puntoOjo);


				lastMouseX = newX;
				lastMouseY = newY;
			}
			
			updateView();
		}

		function handleMouseWheel(event){
			var delta;
			if (event.wheelData){
				delta = event.wheelData
			} else if (event.detail){
				delta = event.detail;
			}

			var deltaP = vec3.create();

			vec3.subtract(deltaP, puntoOjo, puntoMirado);

			vec3.scale(deltaP, deltaP, delta/10+1);
			vec3.add(puntoOjo, puntoMirado, deltaP);
			
			updateView();
		}

		function handleKeyDown(event){
			if (String.fromCharCode(event.keyCode) == "C") {
				camara = (camara + 1) % 3;
			}
			if (String.fromCharCode(event.keyCode) == "I") {
				if(mode == "day"){
					mode = "night";
				
					ReflectionManager.addReflectionToRenderable(agua, "background_night");
					escena.removeConjunto(cielo_dia);
					escena.addConjunto(cielo_noche);
					escena.turnOffLight(light_dia);
					escena.turnOnLight(light_noche1);
					escena.turnOnLight(light_noche2);
					escena.turnOnLight(light_noche3);
					escena.turnOnLight(light_noche4);
					escena.turnOnLight(light_noche5);
					escena.turnOnLight(light_noche6);
					vuelta_al_mundo.setReflectionTextureName("background_night");
					vuelta_al_mundo.setReflectiveness(0.4);
				} else {
					mode = "day";
					
					ReflectionManager.addReflectionToRenderable(agua, "background_day");
					escena.removeConjunto(cielo_noche);
					escena.addConjunto(cielo_dia);
					escena.turnOffLight(light_noche6);
					escena.turnOffLight(light_noche5);
					escena.turnOffLight(light_noche4);
					escena.turnOffLight(light_noche3);
					escena.turnOffLight(light_noche2);
					escena.turnOffLight(light_noche1);
					escena.turnOnLight(light_dia);
					vuelta_al_mundo.setReflectionTextureName("background_day");
					vuelta_al_mundo.setReflectiveness(0.7);
				}
			}
			if(camara == 2){
				var deltaP = vec3.create();
				vec3.subtract(deltaP, puntoOjo, puntoMirado);
				vec3.normalize(deltaP, deltaP);
				if (String.fromCharCode(event.keyCode) == "W") {
					vec3.subtract(puntoOjo, puntoOjo, deltaP);
					vec3.subtract(puntoMirado, puntoMirado, deltaP);
				}
				if (String.fromCharCode(event.keyCode) == "A") {
					vec3.cross(deltaP, deltaP, vecArriba);
					vec3.add(puntoOjo, puntoOjo, deltaP);
					vec3.add(puntoMirado, puntoMirado, deltaP);
				}
				if (String.fromCharCode(event.keyCode) == "S") {
					vec3.add(puntoOjo, puntoOjo, deltaP);
					vec3.add(puntoMirado, puntoMirado, deltaP);
				}
				if (String.fromCharCode(event.keyCode) == "D") {
					vec3.cross(deltaP, deltaP, vecArriba);
					vec3.subtract(puntoOjo, puntoOjo, deltaP);
					vec3.subtract(puntoMirado, puntoMirado, deltaP);
				}
			}
			
			updateView();
		}
		
		function updateView(){
			// Preparamos una matriz de vista.
			var u_view_matrix = gl.getUniformLocation(glProgram, "uVMatrix");
			mat4.identity(vMatrix);
			mat4.lookAt(vMatrix, puntoOjo, puntoMirado, vecArriba);
			gl.uniformMatrix4fv(u_view_matrix, false, vMatrix);
			
			// Preparams la posicion del observador
			var u_view_dir = gl.getUniformLocation(glProgram, "uViewPos");
			gl.uniform3fv(u_view_dir, puntoOjo);
		}
		
		 // SHADERS FUNCTION
		function getShader(gl, id) {
			var shaderScript, src, currentChild, shader;

			// Obtenemos el elemento <script> que contiene el código fuente del shader.
			shaderScript = document.getElementById(id);
			if (!shaderScript) {
				return null;
			}

			// Extraemos el contenido de texto del <script>.
			src = "";
			currentChild = shaderScript.firstChild;
			while(currentChild) {
				if (currentChild.nodeType == currentChild.TEXT_NODE) {
					src += currentChild.textContent;
				}
				currentChild = currentChild.nextSibling;
			}

			// Creamos un shader WebGL según el atributo type del <script>.
			if (shaderScript.type == "x-shader/x-fragment") {
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else if (shaderScript.type == "x-shader/x-vertex") {
				shader = gl.createShader(gl.VERTEX_SHADER);
			} else {
				return null;
			}

			// Le decimos a WebGL que vamos a usar el texto como fuente para el shader.
			gl.shaderSource(shader, src);

			// Compilamos el shader.
			gl.compileShader(shader);  
			  
			// Chequeamos y reportamos si hubo algún error.
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
			  alert("An error occurred compiling the shaders: " + 
					gl.getShaderInfoLog(shader));  
			  return null;  
			}
			  
			return shader;
		}

		function initWebGL()
		{
			canvas = document.getElementById("my-canvas");  
			try{
				gl = canvas.getContext("webgl", { preserveDrawingBuffer: true }) || canvas.getContext("experimental-webgl", { preserveDrawingBuffer: true });   			
				/*var blending = document.getElementById("blending").checked;
				if (blending) {
					gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
				}*/
				canvas.onmousedown = handleMouseDown;
				document.onmouseup = handleMouseUp;
				document.onmousemove = handleMouseMove; 
				document.onkeydown = handleKeyDown;
				document.onkeyup = handleKeyUp;  
				window.addEventListener('DOMMouseScroll', handleMouseWheel);


			}catch(e){
			}
							
			if(gl)
			{
				setupWebGL();
				initShaders();
				setupBuffers();
				requestAnimationFrame(drawScene);
			}else{    
				alert(  "Error: Your browser does not appear to support WebGL.");
			}
		}
		
		function setupWebGL()
		{
			//set the clear color
			gl.clearColor(0.1, 0.1, 0.2, 1.0);     
			gl.enable(gl.DEPTH_TEST);                              
			gl.depthFunc(gl.LEQUAL); 
			gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
			
			gl.viewport(0, 0, canvas.width, canvas.height);
		}
		
		function initShaders()
		{
			// Obtenemos los shaders ya compilados
			var fragmentShader = getShader(gl, "shader-fs-iluminacion");
			var vertexShader = getShader(gl, "shader-vs-iluminacion");

			// Creamos un programa de shaders de WebGL.
			glProgram = gl.createProgram();

			// Asociamos cada shader compilado al programa.
			gl.attachShader(glProgram, vertexShader);
			gl.attachShader(glProgram, fragmentShader);

			// Linkeamos los shaders para generar el programa ejecutable.
			gl.linkProgram(glProgram);

			// Chequeamos y reportamos si hubo algún error.
			if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
			  alert("Unable to initialize the shader program: " + 
					gl.getProgramInfoLog(glProgram));
			  return null;
			}

			// Le decimos a WebGL que de aquí en adelante use el programa generado.
			gl.useProgram(glProgram);
			
			gl.uniform1i(gl.getUniformLocation(glProgram, "uUseWaterEffect"), 0);
			gl.uniform1i(gl.getUniformLocation(glProgram, "uBlendTexture"), 0);
			gl.uniform1i(gl.getUniformLocation(glProgram, "uUseNormalMap"), 0);
			gl.uniform1i(gl.getUniformLocation(glProgram, "uUseReflection"), 0);
			gl.uniform1i(gl.getUniformLocation(glProgram, "uHasTexture"), 0);
			gl.uniform1i(gl.getUniformLocation(glProgram, "uUseLights"), 0);
			gl.uniform1i(gl.getUniformLocation(glProgram, "uSampler"), 0);
			gl.uniform1i(gl.getUniformLocation(glProgram, "uNormalSampler"), 1);
			gl.uniform1i(gl.getUniformLocation(glProgram, "uCubeSampler"), 2);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
		}
		
		function makeShader(src, type)
		{
			//compile the vertex shader
			var shader = gl.createShader(type);
			gl.shaderSource(shader, src);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
			}
			return shader;
		}
		
		function setupBuffers()
		{	
			var dayBox = [
				["xpos.png", gl.TEXTURE_CUBE_MAP_POSITIVE_X],
				["xneg.png", gl.TEXTURE_CUBE_MAP_NEGATIVE_X],
				["ypos.png", gl.TEXTURE_CUBE_MAP_POSITIVE_Y],
				["yneg.png", gl.TEXTURE_CUBE_MAP_NEGATIVE_Y],
				["zpos.png", gl.TEXTURE_CUBE_MAP_POSITIVE_Z],
				["zneg.png", gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]
			];
			ReflectionManager.addReflectionCubeMap(dayBox, "background_day");
			
			var nightBox = [
				["stars_right.jpg", gl.TEXTURE_CUBE_MAP_POSITIVE_X],
				["stars_left.jpg", gl.TEXTURE_CUBE_MAP_NEGATIVE_X],
				["stars_top.jpg", gl.TEXTURE_CUBE_MAP_POSITIVE_Y],
				["stars_bottom.jpg", gl.TEXTURE_CUBE_MAP_NEGATIVE_Y],
				["stars_front.jpg", gl.TEXTURE_CUBE_MAP_POSITIVE_Z],
				["stars_back.jpg", gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]
			];
			ReflectionManager.addReflectionCubeMap(nightBox, "background_night");
			
			/*** DESCOMENTAR ESTO PARA QUE SE CREEN Y ORIENTEN (mas o menos lindo) ESTOS MODELOS ***/
			/*** ESTO YA ESTA TERIMINADO, LO DEJO ACA POR AHORA ***/
			vuelta_al_mundo = new VueltaAlMundo();
			var m1 = mat4.create();
			mat4.translate(m1, m1, vec3.fromValues(-20, 17.1, -10));
			mat4.rotate(m1, m1, -Math.PI/3, vec3.fromValues(0, 1, 0));
			mat4.scale(m1, m1, vec3.fromValues(4, 4, 4));
			vuelta_al_mundo.setTransform(m1);
			vuelta_al_mundo.setReflectionTextureName("background_day");
			vuelta_al_mundo.setReflectiveness(0.7);

			montania_rusa = new MontaniaRusa();
			
			/*** ESTOS PUNTOS SE USAN EN LA CREACION DE LAS CURVAS ***/
			// es un posible recorrido de la montaña rusa, puede ser otro da lo mismo
			
			/*var puntos = [];
			puntos.push(vec3.fromValues(5, 2, 0));
			puntos.push(vec3.fromValues(5, 2, 4));
			puntos.push(vec3.fromValues(5, 3, 5.5));
			puntos.push(vec3.fromValues(5, 4, 7));
			// giros horizontales
			puntos.push(vec3.fromValues(5, 6, 8));
			puntos.push(vec3.fromValues(7, 6.5, 10));
			puntos.push(vec3.fromValues(8, 6.25, 9.5));
			puntos.push(vec3.fromValues(8.5, 6, 9));
			puntos.push(vec3.fromValues(8, 6, 8.5));
			puntos.push(vec3.fromValues(7.5, 6, 9));
			puntos.push(vec3.fromValues(8, 5.75, 9.5));
			puntos.push(vec3.fromValues(8.5, 5.5, 9));
			puntos.push(vec3.fromValues(8, 5.25, 8.5));
			puntos.push(vec3.fromValues(7.5, 5.25, 9));
			puntos.push(vec3.fromValues(8, 5.25, 9.5));
			puntos.push(vec3.fromValues(8.5, 5, 9));
			// end
			puntos.push(vec3.fromValues(8.5, 4.5, 8));
			puntos.push(vec3.fromValues(8.75, 3, 5));
			puntos.push(vec3.fromValues(9, 5, 3));
			puntos.push(vec3.fromValues(8.8, 7, 4));
			puntos.push(vec3.fromValues(8.6, 5, 5));
			puntos.push(vec3.fromValues(8.5, 3, 4));
			puntos.push(vec3.fromValues(8.3, 3, 2));
			puntos.push(vec3.fromValues(8, 2.5, 0.5));
			puntos.push(vec3.fromValues(5, 2, 0));*/
			
			
			/*** DESCOMENTAR ESTO PARA CREAR UNA CURVA ***/
			/*curva1 = new Mesh( new Curva(puntos) );
			var m1 = mat4.create();
			var centro = curva1.getCenter();
			vec3.scale(centro, centro, -1);
			mat4.translate(m1, m1, centro);
			curva1.applyMatrix(m1);*/
			
			/*** DESCOMENTAR ESTO PARA CREAR EL MODELO DE TRACK ***/
			// Track tiene un modelo de riel para la montaña rusa, pero no logre hacer que funcione bien
			// la idea era definir en curva que arme la curva aproximando con rectas de largo predefinido
			// asi le pasaba el largo del modelo este, y despues era cuestion de ponerlo en cada lugar y orientarlo
			/*track = new Track();
			
			var p0 = vec3.fromValues(0, 0, 0);
			var p1 = vec3.fromValues(4, 0, 0);
			// esta funcion deberia trasladar el riel al punto p0, y orientarlo segun el vector p0p1
			// crei que estaba bien hecho, pero cuando lo pruebo en curva2 queda horrible y no alineado
			track.fitToSegment(p0, p1);*/
			
			/*** DESCOMENTAR PARA CREAR CURVA CON TRACKS (anda para el orto y puede que se laguee banda) ***/
			//curva2 = new CurvedGeometry(puntos, new Track());
			puntoOjo = vec3.fromValues(0,0,-80);
			puntoMirado = vec3.fromValues(0,0,0);
			//vecArriba = vec3.fromValues(-0.38,0.92,0);
			vecArriba = vec3.fromValues(0,1,0);
			
			/*** CREO LA ESCENA ***/
			escena = new Scene();
			//escena.addConjunto(vuelta_al_mundo);
			var m4 = mat4.create();
			mat4.translate(m4, m4, vec3.fromValues(0, 2, 0));
			montania_rusa.applyMatrix(m4);
			escena.addConjunto(montania_rusa);
			//escena.addConjunto(vuelta_al_mundo);

			// esta es una luz blanca de arriba (de infinito)
			light_dia = new DirectionalLight(vec3.fromValues(0.0, 1, 0.0), 
										vec3.fromValues(0.5, 0.5, 0.5), 
										vec3.fromValues(1.5, 1.5, 1.5));
			escena.addLight(light_dia);
			
			var ip_night = 0.25;
			var ia_night = 0.05;
			light_noche1 = new PointLight(vec3.fromValues(-20.0, -10.0, 5.0), 
										vec3.fromValues(ip_night, ip_night, ip_night), 
										vec3.fromValues(ia_night, ia_night, ia_night));
			escena.addLight(light_noche1);
			light_noche1.turnOff();
										
			light_noche2 = new PointLight(vec3.fromValues(20.0, -10.0, -10.0), 
										vec3.fromValues(ip_night, ip_night, ip_night), 
										vec3.fromValues(ia_night, ia_night, ia_night));
			escena.addLight(light_noche2);
			light_noche2.turnOff();
			
			light_noche3 = new PointLight(vec3.fromValues(30.0, -10.0, 40.0), 
										vec3.fromValues(ip_night, ip_night, ip_night), 
										vec3.fromValues(ia_night, ia_night, ia_night));
			escena.addLight(light_noche3);
			light_noche3.turnOff();
										
			light_noche4 = new PointLight(vec3.fromValues(5.0, -10.0, 10.0), 
										vec3.fromValues(ip_night, ip_night, ip_night), 
										vec3.fromValues(ia_night, ia_night, ia_night));
			escena.addLight(light_noche4);
			light_noche4.turnOff();
			
			light_noche5 = new PointLight(vec3.fromValues(-15.0, -10.0, -20.0), 
										vec3.fromValues(ip_night, ip_night, ip_night), 
										vec3.fromValues(ia_night, ia_night, ia_night));
			escena.addLight(light_noche5);
			light_noche5.turnOff();
			
			light_noche6 = new PointLight(vec3.fromValues(-30.0, -10.0, 40.0), 
										vec3.fromValues(ip_night, ip_night, ip_night), 
										vec3.fromValues(ia_night, ia_night, ia_night));
			escena.addLight(light_noche6);
			light_noche6.turnOff();
			
			/*** ESTO DEFINE LA GEOMETRIA DEL PISO, SU TEXTURA Y COMO MAPEARLA ***/	
			agua = new Agua();
			var m_agua = mat4.create();
			mat4.translate(m_agua, m_agua, vec3.fromValues(0, -15.1, 0));
			mat4.rotate(m_agua, m_agua, -Math.PI/2, vec3.fromValues(1, 0, 0));
			mat4.scale(m_agua, m_agua, vec3.fromValues(1000, 1000, 1000));
			agua.applyMatrix(m_agua);
			escena.addConjunto(agua);
			agua.setReflectiveness(0.4);
			ReflectionManager.addReflectionToRenderable(agua, "background_day");
			//ReflectionManager.addReflectionToRenderable(agua, "background_night");
			
			piso = new TexturedMesh( "grass_diffuse2.jpg", TexturedMesh.mapper_piso, new Cuadrado(), 15, true, 0.5, 1, 0.5);
			piso.loadNormalTexture("grass_normal2.jpg");
			var m_piso = mat4.create();
			mat4.translate(m_piso, m_piso, vec3.fromValues(0, -15, 0));
			mat4.rotate(m_piso, m_piso, -Math.PI/2, vec3.fromValues(1, 0, 0));
			mat4.scale(m_piso, m_piso, vec3.fromValues(100, 100, 100));
			piso.applyMatrix(m_piso);
			escena.addConjunto(piso);
			
			/*** ESTO DEFINE LA GEOMETRIA DEL CIELO, SU TEXTURA Y COMO MAPEARLA ***/
			cielo_dia = new TexturedMesh("sky.jpg", TexturedMesh.mapper_cielo, new Esfera(), false, false);
			cielo_noche = new TexturedMesh("night6.jpg", TexturedMesh.mapper_cielo, new Esfera(), false, false);
			var m_cielo = mat4.create();
			mat4.translate(m_cielo, m_cielo, vec3.fromValues(0, -15, 0));
			mat4.scale(m_cielo, m_cielo, vec3.fromValues(500, 500, 500));
			mat4.rotate(m_cielo, m_cielo, -Math.PI/2, vec3.fromValues(1, 0, 0));
			cielo_dia.applyMatrix(m_cielo);
			cielo_noche.applyMatrix(m_cielo);
			escena.addConjunto(cielo_dia);
			
			sillas_giratorias = new SillasGiratorias();
			var m2 = mat4.create();
			mat4.translate(m2, m2, vec3.fromValues(5, -11.99, 10));
			mat4.rotate(m2, m2, -Math.PI/3, vec3.fromValues(0, 1, 0));
			mat4.scale(m2, m2, vec3.fromValues(2, 2, 2));
			sillas_giratorias.setTransform(m2);
			//escena.addConjunto(sillas_giratorias);
			
			// Preparamos una matriz de perspectiva.
			var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
			mat4.perspective(pMatrix, 45, 640.0/480.0, 0.1, 100000.0);
			gl.uniformMatrix4fv(u_proj_matrix, false, pMatrix);
			updateView();
		}
		
		function drawScene()
		{
			requestAnimationFrame(drawScene);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			
			// Transformaciones a los modelos
			/*** DESCOMENTAR ESTO PARA QUE LOS MODELOS GIREN ***/
			/*** ESTO YA ESTA TERIMINADO, LO DEJO ACA POR AHORA ***/
			vuelta_al_mundo.girar();				
			sillas_giratorias.girar();
			
			// Dibujar modelos
			/*** DESCOMENTAR ESTO PARA QUE LOS MODELOS SE DIBUJEN ***/
			/*** ESTO YA ESTA TERIMINADO, LO DEJO ACA POR AHORA ***/
			escena.render();
		}

	</script>
</head>
<body onload="initWebGL()">
	<center>
		<h1>Sistemas Gráficos - 66.71</h1>
		<h2>WebGL - Grilla de vértices</h2>
		<canvas id="my-canvas" width="900" height="500">
		Your browser does not support the HTML5 canvas element.
		</scanvas>
		
	</center>
</body>

